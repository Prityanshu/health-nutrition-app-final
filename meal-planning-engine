# app/services/nutrition.py
from typing import List, Dict, Optional
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_

from app.database import User, FoodItem, ActivityLevel
from app.schemas import MealItem, MealPlan, DayPlan

class NutritionCalculator:
    @staticmethod
    def calculate_bmr(user: User) -> float:
        """Calculate Basal Metabolic Rate using Mifflin-St Jeor equation"""
        if not all([user.weight_kg, user.height_cm, user.age, user.gender]):
            return 1800  # Default BMR
        
        if user.gender.value == "male":
            bmr = (10 * user.weight_kg) + (6.25 * user.height_cm) - (5 * user.age) + 5
        else:
            bmr = (10 * user.weight_kg) + (6.25 * user.height_cm) - (5 * user.age) - 161
        
        return bmr
    
    @staticmethod
    def calculate_tdee(user: User) -> float:
        """Calculate Total Daily Energy Expenditure"""
        bmr = NutritionCalculator.calculate_bmr(user)
        
        activity_multipliers = {
            ActivityLevel.SEDENTARY: 1.2,
            ActivityLevel.LIGHT: 1.375,
            ActivityLevel.MODERATE: 1.55,
            ActivityLevel.ACTIVE: 1.725,
            ActivityLevel.VERY_ACTIVE: 1.9
        }
        
        multiplier = activity_multipliers.get(user.activity_level, 1.55)
        return bmr * multiplier
    
    @staticmethod
    def get_target_calories(user: User, goal_adjustment: float = 0) -> float:
        """Get target calories based on user's goal"""
        tdee = NutritionCalculator.calculate_tdee(user)
        return tdee + goal_adjustment

class MealPlanner:
    def __init__(self, db: Session):
        self.db = db
        self.nutrition_calc = NutritionCalculator()
    
    def filter_foods_by_health_conditions(self, foods: List[FoodItem], health_conditions: Dict) -> List[FoodItem]:
        """Filter foods based on user's health conditions"""
        if not health_conditions:
            return foods
        
        filtered = []
        for food in foods:
            include_food = True
            
            # Diabetes check
            if health_conditions.get("diabetes", 0):
                if not food.diabetic_friendly or food.gi > 55:
                    include_food = False
            
            # Hypertension check
            if health_conditions.get("hypertension", 0):
                if not (food.hypertension_friendly and food.low_sodium):
                    include_food = False
            
            if include_food:
                filtered.append(food)
        
        return filtered
    
    def get_filtered_foods(self, user: User, cuisine_type: Optional[str] = None) -> List[FoodItem]:
        """Get foods filtered by user preferences and health conditions"""
        query = self.db.query(FoodItem)
        
        # Filter by cuisine if specified
        if cuisine_type and cuisine_type != "mixed":
            query = query.filter(FoodItem.cuisine_type == cuisine_type)
        elif user.cuisine_pref and user.cuisine_pref != "mixed":
            query = query.filter(FoodItem.cuisine_type == user.cuisine_pref)
        
        foods = query.all()
        
        # Apply health condition filters
        foods = self.filter_foods_by_health_conditions(foods, user.health_conditions)
        
        return foods
    
    def plan_day(self, user: User, meals_per_day: int = 3, cuisine_type: Optional[str] = None, target_calories: Optional[float] = None) -> DayPlan:
        """Generate a meal plan for one day"""
        if not target_calories:
            target_calories = self.nutrition_calc.get_target_calories(user)
        
        foods = self.get_filtered_foods(user, cuisine_type)
        
        if not foods:
            raise ValueError("No suitable foods found for user preferences")
        
        # Sort foods by protein density and cost
        foods_sorted = sorted(foods, key=lambda f: (-f.protein_g/f.calories if f.calories > 0 else 0, f.cost))
        
        per_meal_target = target_calories / meals_per_day
        meals = []
        total_day_calories = 0
        total_day_protein = 0
        total_day_cost = 0
        
        for meal_idx in range(meals_per_day):
            meal_items = []
            meal_calories = 0
            meal_protein = 0
            meal_cost = 0
            
            # Select 1-3 foods per meal
            foods_used = 0
            food_idx = 0
            
            while (meal_calories < per_meal_target * 0.9 and 
                   foods_used < 3 and 
                   food_idx < len(foods_sorted) and
                   meal_cost + foods_sorted[food_idx].cost <= user.budget_per_day / meals_per_day):
                
                food = foods_sorted[food_idx]
                quantity = min(2.0, per_meal_target / food.calories) if food.calories > 0 else 1.0
                
                meal_item = MealItem(
                    food_id=food.id,
                    name=food.name,
                    calories=food.calories * quantity,
                    protein_g=food.protein_g * quantity,
                    carbs_g=food.carbs_g * quantity,
                    fat_g=food.fat_g * quantity,
                    quantity=quantity,
                    cost=food.cost * quantity
                )
                
                meal_items.append(meal_item)
                meal_calories += meal_item.calories
                meal_protein += meal_item.protein_g
                meal_cost += meal_item.cost
                
                foods_used += 1
                food_idx += 1
            
            meal_plan = MealPlan(
                meal_index=meal_idx + 1,
                items=meal_items,
                total_calories=meal_calories,
                total_protein=meal_protein,
                total_cost=meal_cost
            )
            
            meals.append(meal_plan)
            total_day_calories += meal_calories
            total_day_protein += meal_protein
            total_day_cost += meal_cost
        
        return DayPlan(
            day=1,
            meals=meals,
            total_calories=total_day_calories,
            total_protein=total_day_protein,
            total_cost=total_day_cost
        )
    
    def plan_week(self, user: User, meals_per_day: int = 3, cuisine_type: Optional[str] = None) -> List[DayPlan]:
        """Generate a meal plan for a week"""
        week_plan = []
        
        for day in range(1, 8):
            day_plan = self.plan_day(user, meals_per_day, cuisine_type)
            day_plan.day = day
            week_plan.append(day_plan)
        
        return week_plan

# app/routers/planner.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.database import get_db, User
from app.auth import get_current_user
from app.schemas import MealPlanRequest, DayPlan
from app.services.nutrition import MealPlanner

router = APIRouter()

@router.post("/day", response_model=DayPlan)
def plan_day(
    request: MealPlanRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    try:
        planner = MealPlanner(db)
        day_plan = planner.plan_day(
            user=current_user,
            meals_per_day=request.meals_per_day,
            cuisine_type=request.cuisine_type,
            target_calories=request.target_calories
        )
        return day_plan
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/week", response_model=List[DayPlan])
def plan_week(
    request: MealPlanRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    try:
        planner = MealPlanner(db)
        week_plan = planner.plan_week(
            user=current_user,
            meals_per_day=request.meals_per_day,
            cuisine_type=request.cuisine_type
        )
        return week_plan
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))