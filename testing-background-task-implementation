# app/workers/tasks.py - Background Tasks with Celery
from celery import Celery
import os
from typing import Dict, Any
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
import io

# Initialize Celery
celery_app = Celery('nutrition_app')
celery_app.conf.update(
    broker_url=os.getenv('REDIS_URL', 'redis://localhost:6379/0'),
    result_backend=os.getenv('REDIS_URL', 'redis://localhost:6379/0'),
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
)

@celery_app.task
def send_email(to_email: str, subject: str, body: str):
    """Send email notification"""
    try:
        smtp_server = os.getenv('SMTP_SERVER', 'smtp.gmail.com')
        smtp_port = int(os.getenv('SMTP_PORT', '587'))
        email_address = os.getenv('EMAIL_ADDRESS')
        email_password = os.getenv('EMAIL_PASSWORD')
        
        if not all([email_address, email_password]):
            print("Email credentials not configured")
            return False
        
        msg = MimeMultipart()
        msg['From'] = email_address
        msg['To'] = to_email
        msg['Subject'] = subject
        
        msg.attach(MimeText(body, 'plain'))
        
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(email_address, email_password)
        text = msg.as_string()
        server.sendmail(email_address, to_email, text)
        server.quit()
        
        print(f"Email sent successfully to {to_email}")
        return True
    except Exception as e:
        print(f"Failed to send email: {str(e)}")
        return False

@celery_app.task
def generate_meal_plan_pdf(user_id: int, meal_plan_data: Dict[str, Any]) -> str:
    """Generate PDF for meal plan"""
    try:
        buffer = io.BytesIO()
        p = canvas.Canvas(buffer, pagesize=letter)
        width, height = letter
        
        # Title
        p.setFont("Helvetica-Bold", 16)
        p.drawString(50, height - 50, "Weekly Meal Plan")
        
        y_position = height - 100
        
        for day_plan in meal_plan_data.get('days', []):
            p.setFont("Helvetica-Bold", 14)
            p.drawString(50, y_position, f"Day {day_plan.get('day', 1)}")
            y_position -= 30
            
            for meal in day_plan.get('meals', []):
                p.setFont("Helvetica-Bold", 12)
                p.drawString(70, y_position, f"Meal {meal.get('meal_index', 1)}")
                y_position -= 20
                
                for item in meal.get('items', []):
                    p.setFont("Helvetica", 10)
                    item_text = f"- {item.get('name', '')} ({item.get('quantity', 1):.1f} serving, {item.get('calories', 0):.0f} cal)"
                    p.drawString(90, y_position, item_text)
                    y_position -= 15
                
                y_position -= 10
            
            if y_position < 100:  # Start new page if needed
                p.showPage()
                y_position = height - 50
        
        p.save()
        
        # Save PDF file
        filename = f"meal_plan_user_{user_id}.pdf"
        buffer.seek(0)
        
        with open(f"static/pdfs/{filename}", "wb") as f:
            f.write(buffer.getvalue())
        
        buffer.close()
        return filename
        
    except Exception as e:
        print(f"Failed to generate PDF: {str(e)}")
        return ""

@celery_app.task
def send_reminder_notifications():
    """Send daily meal logging reminders"""
    # This would query users who haven't logged meals today
    # and send them reminder notifications
    print("Sending reminder notifications...")
    return "Reminders sent"

@celery_app.task
def update_user_recommendations(user_id: int):
    """Update user's meal recommendations based on recent logs"""
    # This would implement ML-based recommendation updates
    print(f"Updating recommendations for user {user_id}")
    return f"Recommendations updated for user {user_id}"

# app/tests/test_auth.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.main import app
from app.database import Base, get_db

# Test database
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def override_get_db():
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()

app.dependency_overrides[get_db] = override_get_db
client = TestClient(app)

@pytest.fixture(scope="module")
def setup_database():
    Base.metadata.create_all(bind=engine)
    yield
    Base.metadata.drop_all(bind=engine)

def test_register_user(setup_database):
    """Test user registration"""
    response = client.post(
        "/api/auth/register",
        json={
            "email": "test@example.com",
            "password": "testpassword123",
            "name": "Test User",
            "age": 25,
            "height_cm": 170.0,
            "weight_kg": 70.0,
            "activity_level": "moderate"
        }
    )
    assert response.status_code == 201
    data = response.json()
    assert data["email"] == "test@example.com"
    assert data["name"] == "Test User"

def test_register_duplicate_email(setup_database):
    """Test registration with duplicate email"""
    # First registration
    client.post(
        "/api/auth/register",
        json={
            "email": "duplicate@example.com",
            "password": "testpassword123",
            "name": "Test User 1",
        }
    )
    
    # Second registration with same email
    response = client.post(
        "/api/auth/register",
        json={
            "email": "duplicate@example.com",
            "password": "testpassword456",
            "name": "Test User 2",
        }
    )
    assert response.status_code == 400

def test_login_success(setup_database):
    """Test successful login"""
    # Register user first
    client.post(
        "/api/auth/register",
        json={
            "email": "login@example.com",
            "password": "testpassword123",
            "name": "Login Test User",
        }
    )
    
    # Login
    response = client.post(
        "/api/auth/token",
        json={
            "email": "login@example.com",
            "password": "testpassword123"
        }
    )
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

def test_login_invalid_credentials(setup_database):
    """Test login with invalid credentials"""
    response = client.post(
        "/api/auth/token",
        json={
            "email": "nonexistent@example.com",
            "password": "wrongpassword"
        }
    )
    assert response.status_code == 401

def test_get_current_user(setup_database):
    """Test getting current user info"""
    # Register and login
    client.post(
        "/api/auth/register",
        json={
            "email": "current@example.com",
            "password": "testpassword123",
            "name": "Current User",
        }
    )
    
    login_response = client.post(
        "/api/auth/token",
        json={
            "email": "current@example.com",
            "password": "testpassword123"
        }
    )
    token = login_response.json()["access_token"]
    
    # Get current user
    response = client.get(
        "/api/auth/me",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert data["email"] == "current@example.com"

# app/tests/test_meal_planning.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

@pytest.fixture
def authenticated_user():
    """Create and authenticate a test user"""
    # Register user
    register_response = client.post(
        "/api/auth/register",
        json={
            "email": "planner@example.com",
            "password": "testpassword123",
            "name": "Planner User",
            "age": 30,
            "height_cm": 175.0,
            "weight_kg": 75.0,
            "activity_level": "moderate"
        }
    )
    
    # Login
    login_response = client.post(
        "/api/auth/token",
        json={
            "email": "planner@example.com",
            "password": "testpassword123"
        }
    )
    token = login_response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}

def test_generate_day_plan(authenticated_user):
    """Test generating a day meal plan"""
    response = client.post(
        "/api/planner/day",
        headers=authenticated_user,
        json={
            "meals_per_day": 3,
            "cuisine_type": "indian"
        }
    )
    
    if response.status_code == 400 and "No suitable foods found" in response.json().get("detail", ""):
        # This is expected if no sample data is loaded
        pytest.skip("No sample food data available")
    
    assert response.status_code == 200
    data = response.json()
    assert "meals" in data
    assert len(data["meals"]) == 3
    assert "total_calories" in data

def test_generate_week_plan(authenticated_user):
    """Test generating a week meal plan"""
    response = client.post(
        "/api/planner/week",
        headers=authenticated_user,
        json={
            "meals_per_day": 3,
            "cuisine_type": "continental"
        }
    )
    
    if response.status_code == 400:
        pytest.skip("No sample food data available")
    
    assert response.status_code == 200
    data = response.json()
    assert len(data) == 7  # 7 days

# app/tests/test_meal_logging.py
def test_log_meal(authenticated_user):
    """Test logging a meal"""
    response = client.post(
        "/api/meals/log",
        headers=authenticated_user,
        json={
            "food_id": 1,  # Assuming food item with ID 1 exists
            "quantity": 1.5,
            "planned": True
        }
    )
    
    if response.status_code == 404:
        pytest.skip("No sample food data available")
    
    assert response.status_code == 201
    data = response.json()
    assert data["food_id"] == 1
    assert data["quantity"] == 1.5
    assert data["planned"] == True

def test_get_meal_logs(authenticated_user):
    """Test getting meal logs"""
    response = client.get(
        "/api/meals/logs",
        headers=authenticated_user
    )
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)

# app/tests/test_tracking.py
def test_get_tracking_summary(authenticated_user):
    """Test getting tracking summary"""
    response = client.get(
        "/api/tracking/summary",
        headers=authenticated_user
    )
    assert response.status_code == 200
    data = response.json()
    assert "total_calories" in data
    assert "daily_breakdown" in data

def test_get_adherence_score(authenticated_user):
    """Test getting adherence score"""
    response = client.get(
        "/api/tracking/adherence",
        headers=authenticated_user
    )
    assert response.status_code == 200
    data = response.json()
    assert "overall_score" in data
    assert "plan_adherence" in data

# app/tests/conftest.py
import pytest
import os
import tempfile
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.database import Base

@pytest.fixture(scope="session")
def temp_db():
    """Create a temporary database for testing"""
    db_fd, db_path = tempfile.mkstemp(suffix='.db')
    engine = create_engine(f"sqlite:///{db_path}", connect_args={"check_same_thread": False})
    Base.metadata.create_all(engine)
    
    yield engine
    
    os.close(db_fd)
    os.unlink(db_path)

# Run tests with: pytest app/tests/ -v

# app/services/cache.py - Redis Caching Service
import redis
import json
import os
from typing import Any, Optional
from datetime import timedelta

class CacheService:
    def __init__(self):
        redis_url = os.getenv('REDIS_URL', 'redis://localhost:6379/0')
        self.redis_client = redis.from_url(redis_url, decode_responses=True)
    
    def set(self, key: str, value: Any, expire: timedelta = None) -> bool:
        """Set a value in cache"""
        try:
            serialized_value = json.dumps(value)
            if expire:
                return self.redis_client.setex(key, expire, serialized_value)
            else:
                return self.redis_client.set(key, serialized_value)
        except Exception as e:
            print(f"Cache set error: {e}")
            return False
    
    def get(self, key: str) -> Optional[Any]:
        """Get a value from cache"""
        try:
            cached_value = self.redis_client.get(key)
            if cached_value:
                return json.loads(cached_value)
            return None
        except Exception as e:
            print(f"Cache get error: {e}")
            return None
    
    def delete(self, key: str) -> bool:
        """Delete a key from cache"""
        try:
            return bool(self.redis_client.delete(key))
        except Exception as e:
            print(f"Cache delete error: {e}")
            return False
    
    def clear_user_cache(self, user_id: int):
        """Clear all cached data for a user"""
        pattern = f"user:{user_id}:*"
        keys = self.redis_client.keys(pattern)
        if keys:
            self.redis_client.delete(*keys)

# Initialize cache service
cache = CacheService()

# Usage example in meal planning
def get_cached_meal_plan(user_id: int, plan_key: str):
    """Get cached meal plan"""
    cache_key = f"user:{user_id}:meal_plan:{plan_key}"
    return cache.get(cache_key)

def cache_meal_plan(user_id: int, plan_key: str, meal_plan: dict):
    """Cache meal plan for 24 hours"""
    cache_key = f"user:{user_id}:meal_plan:{plan_key}"
    cache.set(cache_key, meal_plan, expire=timedelta(hours=24))

# app/middleware/rate_limit.py - Rate Limiting Middleware
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
import time
from collections import defaultdict, deque
from typing import Dict, Deque
import asyncio

class RateLimiter:
    def __init__(self, calls: int, period: int):
        self.calls = calls
        self.period = period
        self.clients: Dict[str, Deque[float]] = defaultdict(deque)
    
    def is_allowed(self, client_id: str) -> bool:
        now = time.time()
        client_calls = self.clients[client_id]
        
        # Remove old calls outside the period
        while client_calls and client_calls[0] <= now - self.period:
            client_calls.popleft()
        
        # Check if limit exceeded
        if len(client_calls) >= self.calls:
            return False
        
        # Add current call
        client_calls.append(now)
        return True

# Create rate limiters
auth_limiter = RateLimiter(calls=5, period=300)  # 5 calls per 5 minutes
api_limiter = RateLimiter(calls=100, period=3600)  # 100 calls per hour

async def rate_limit_middleware(request: Request, call_next):
    """Rate limiting middleware"""
    client_ip = request.client.host
    path = request.url.path
    
    # Apply different limits based on endpoint
    if path.startswith('/api/auth/'):
        if not auth_limiter.is_allowed(client_ip):
            raise HTTPException(
                status_code=429, 
                detail="Too many authentication attempts. Please try again later."
            )
    else:
        if not api_limiter.is_allowed(client_ip):
            raise HTTPException(
                status_code=429, 
                detail="API rate limit exceeded. Please try again later."
            )
    
    response = await call_next(request)
    return response

# Add to main.py:
# from app.middleware.rate_limit import rate_limit_middleware
# app.middleware("http")(rate_limit_middleware)