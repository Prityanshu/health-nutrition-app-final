# app/auth.py
from datetime import datetime, timedelta
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from passlib.context import CryptContext
from jose import JWTError, jwt
from sqlalchemy.orm import Session

from app.database import get_db, User
from app.config import settings

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(credentials.credentials, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.email == email).first()
    if user is None:
        raise credentials_exception
    return user

# app/schemas.py
from pydantic import BaseModel, EmailStr
from typing import Optional, List, Dict, Any
from datetime import datetime
from app.database import ActivityLevel, GoalType, Gender, PrepComplexity

# User schemas
class UserCreate(BaseModel):
    email: EmailStr
    password: str
    name: str
    age: Optional[int] = None
    gender: Optional[Gender] = None
    height_cm: Optional[float] = None
    weight_kg: Optional[float] = None
    activity_level: ActivityLevel = ActivityLevel.MODERATE
    cuisine_pref: str = "mixed"
    health_conditions: Dict[str, Any] = {}
    budget_per_day: float = 50.0

class UserUpdate(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None
    gender: Optional[Gender] = None
    height_cm: Optional[float] = None
    weight_kg: Optional[float] = None
    activity_level: Optional[ActivityLevel] = None
    cuisine_pref: Optional[str] = None
    health_conditions: Optional[Dict[str, Any]] = None
    budget_per_day: Optional[float] = None

class UserResponse(BaseModel):
    id: int
    email: str
    name: str
    age: Optional[int]
    gender: Optional[Gender]
    height_cm: Optional[float]
    weight_kg: Optional[float]
    activity_level: ActivityLevel
    cuisine_pref: str
    health_conditions: Dict[str, Any]
    budget_per_day: float
    created_at: datetime
    
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

# Food Item schemas
class FoodItemResponse(BaseModel):
    id: int
    name: str
    cuisine_type: Optional[str]
    calories: float
    protein_g: float
    carbs_g: float
    fat_g: float
    fiber_g: float
    cost: float
    gi: float
    low_sodium: bool
    diabetic_friendly: bool
    hypertension_friendly: bool
    prep_complexity: PrepComplexity
    ingredients: Optional[str]
    tags: List[str]
    
    class Config:
        from_attributes = True

# Meal Planning schemas
class MealPlanRequest(BaseModel):
    meals_per_day: int = 3
    days: int = 1
    cuisine_type: Optional[str] = None
    target_calories: Optional[float] = None

class MealItem(BaseModel):
    food_id: int
    name: str
    calories: float
    protein_g: float
    carbs_g: float
    fat_g: float
    quantity: float
    cost: float

class MealPlan(BaseModel):
    meal_index: int
    items: List[MealItem]
    total_calories: float
    total_protein: float
    total_cost: float

class DayPlan(BaseModel):
    day: int
    meals: List[MealPlan]
    total_calories: float
    total_protein: float
    total_cost: float

# Meal Logging schemas
class MealLogCreate(BaseModel):
    food_id: int
    quantity: float = 1.0
    timestamp: Optional[datetime] = None
    planned: bool = False

class MealLogResponse(BaseModel):
    id: int
    food_id: int
    quantity: float
    timestamp: datetime
    planned: bool
    food_item: FoodItemResponse
    
    class Config:
        from_attributes = True

# Goal schemas
class GoalCreate(BaseModel):
    goal_type: GoalType
    target_weight: Optional[float] = None
    end_date: Optional[datetime] = None

class GoalResponse(BaseModel):
    id: int
    goal_type: GoalType
    target_weight: Optional[float]
    start_date: datetime
    end_date: Optional[datetime]
    is_active: bool
    
    class Config:
        from_attributes = True